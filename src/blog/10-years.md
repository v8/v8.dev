---
title: 'Celebrating 10 years of V8'
author: 'Mathias Bynens ([@mathias](https://twitter.com/mathias)), V8 historian'
avatars:
  - 'mathias-bynens'
date: 2018-09-11 19:00:00
tags:
  - benchmarks
tweet: '1039559389324238850'
---
This month marks the 10-year anniversary of shipping not just Google Chrome, but also the V8 project. This post gives an overview of major milestones for the V8 project in the past 10 years as well as the years before, when the project was still secret.

<figure>
  <div class="video video-16:9">
    <iframe src="https://www.youtube.com/embed/G0vnrPTuxZA" width="640" height="360" loading="lazy"></iframe>
  </div>
  <figcaption>A visualization of the V8 code base over time, created using <a href="http://gource.io/"><code>gource</code></a>.</figcaption>
</figure>

## Before V8 shipped: the early years

Google hired [Lars Bak](https://en.wikipedia.org/wiki/Lars_Bak_%28computer_programmer%29) in the autumn of **2006** to build a new JavaScript engine for the Chrome web browser, which at the time was still a secret internal Google project. Lars had recently moved back to Aarhus, Denmark, from Silicon Valley. Since there was no Google office there and Lars wanted to remain in Denmark, Lars and several of the project’s original engineers began working on the project in an outbuilding on his farm. The new JavaScript runtime was christened “V8”, a playful reference to the powerful engine you can find in a classic muscle car. Later, when the V8 team had grown, the developers moved from their modest quarters to a modern office building in Aarhus, but the team took with them their singular drive and focus on building the fastest JavaScript runtime on the planet.

## Launching and evolving V8

V8 went open-source the same day [Chrome was launched](https://blog.chromium.org/2008/09/welcome-to-chromium_02.html): on September 2nd, **2008**. [The initial commit](https://chromium.googlesource.com/v8/v8/+/43d26ecc3563a46f62a0224030667c8f8f3f6ceb) dates back to June 30th, 2008. Prior to that date, V8 development happened in a private CVS repository. Initially, V8 supported only the ia32 and ARM instruction sets and used [SCons](https://scons.org/) as its build system.

**2009** saw the introduction of a brand new regular expression engine named [Irregexp](https://blog.chromium.org/2009/02/irregexp-google-chromes-new-regexp.html), resulting in performance improvements for real-world regular expressions. With the introduction of an x64 port, the number of supported instruction sets increased from two to three. 2009 also marked [the first release of the Node.js project](https://github.com/nodejs/node-v0.x-archive/releases/tag/v0.0.1), which embeds V8. The possibility for non-browser projects to embed V8 was [explicitly mentioned](https://www.google.com/googlebooks/chrome/big_16.html) in the original Chrome comic. With Node.js, it actually happened! Node.js grew to be one of the most popular JavaScript ecosystems.

**2010** witnessed a big boost in runtime performance as V8 introduced a brand-new optimizing JIT compiler. [Crankshaft](https://blog.chromium.org/2010/12/new-crankshaft-for-v8.html) generated machine code that was twice as fast and 30% smaller than the previous (unnamed) V8 compiler. That same year, V8 added its fourth instruction set: 32-bit MIPS.

**2011** came, and garbage collection was vastly improved. [A new incremental garbage collector](https://blog.chromium.org/2011/11/game-changer-for-interactive.html) drastically reduced pause times while maintaining great peak performance and low memory usage. V8 introduced the concept of Isolates, which allows embedders to spin up multiple instances of the V8 runtime in a process, paving the way for lighter-weight Web Workers in Chrome. The first of V8’s two build system migrations occurred as we transitioned from SCons to [GYP](https://gyp.gsrc.io/). We implemented support for ES5 strict mode. Meanwhile, development moved from Aarhus to Munich (Germany) under new leadership with lots of cross-pollination from the original team in Aarhus.

**2012** was a year of benchmarks for the V8 project. The team did speed sprints to optimize V8’s performance as measured through the [SunSpider](https://webkit.org/perf/sunspider/sunspider.html) and [Kraken](https://krakenbenchmark.mozilla.org/) benchmark suites. Later, we developed a new benchmark suite named [Octane](https://chromium.github.io/octane/) (with [V8 Bench](http://www.netchain.com/Tools/v8/) at its core) that brought peak performance competition to the forefront and spurred massive improvements in runtime and JIT technology in all major JS engines. One outcome of these efforts was the switch from randomized sampling to a deterministic, count-based technique for detecting “hot” functions in V8’s runtime profiler. This made it significantly less likely that some page loads (or benchmark runs) would randomly be much slower than others.

**2013** witnessed the appearance of a low-level subset of JavaScript named [asm.js](http://asmjs.org/). Since asm.js is limited to statically-typed arithmetic, function calls, and heap accesses with primitive types only, validated asm.js code could run with predictable performance. We released a new version of Octane, [Octane 2.0](https://blog.chromium.org/2013/11/announcing-octane-20.html) with updates to existing benchmarks as well as new benchmarks that target use cases like asm.js. Octane spurred the development of new compiler optimizations like [allocation folding](https://static.googleusercontent.com/media/research.google.com/en//pubs/archive/42478.pdf) and [allocation-site-based optimizations for type transitioning and pretenuring](https://static.googleusercontent.com/media/research.google.com/en//pubs/archive/43823.pdf) that vastly improved peak performance. As part of an effort we internally nicknamed “Handlepocalypse”, the V8 Handle API was completely rewritten to make it easier to use correctly and safely. Also in 2013, Chrome’s implementation of `TypedArray`s in JavaScript was [moved from Blink to V8](https://codereview.chromium.org/13064003).

In **2014**, V8 moved some of the work of JIT compilation off the main thread with [concurrent compilation](https://blog.chromium.org/2014/02/compiling-in-background-for-smoother.html), reducing jank and significantly improving performance. Later that year, we [landed](https://github.com/v8/v8/commit/a1383e2250dc5b56b777f2057f1600537f02023e) the initial version of a new optimizing compiler named TurboFan. Meanwhile, our partners helped port V8 to three new instruction set architectures: PPC, MIPS64, and ARM64. Following Chromium, V8 transitioned to yet another build system, [GN](https://gn.googlesource.com/gn/#gn). The V8 testing infrastructure saw significant improvements, with a _Tryserver_ now available to test each patch on various build bots before landing. For source control, V8 migrated from SVN to Git.

**2015** was a busy year for V8 on a number of fronts. We implemented [code caching and script streaming](https://blog.chromium.org/2015/03/new-javascript-techniques-for-rapid.html), significantly speeding up web page load times. Work on our runtime system’s use of allocation mementos was [published in ISMM 2015](https://ai.google/research/pubs/pub43823). Later that year, we [kicked off](https://github.com/v8/v8/commit/7877c4e0c77b5c2b97678406eab7e9ad6eba4a4d) the work on a new interpreter named Ignition. We experimented with the idea of subsetting JavaScript with [strong mode](https://docs.google.com/document/d/1Qk0qC4s_XNCLemj42FqfsRLp49nDQMZ1y7fwf5YjaI4/view) to achieve stronger guarantees and more predictable performance. We implemented strong mode behind a flag, but later found its benefits did not justify the costs. The addition of a [commit queue](https://dev.chromium.org/developers/testing/commit-queue) made big improvements in productivity and stability. V8’s garbage collector also began cooperating with embedders such as Blink to schedule garbage collection work during idle periods. [Idle-time garbage collection](/blog/free-garbage-collection) significantly reduced observable garbage collection jank and memory consumption. In December, [the first WebAssembly prototype](https://github.com/titzer/v8-native-prototype) landed in V8.

In **2016**, we shipped the last pieces of the ES2015 (previously known as “ES6”) feature set (including promises, class syntax, lexical scoping, destructuring, and more), as well as some ES2016 features. We also started rolling out the new Ignition and TurboFan pipeline, using it to [compile and optimize ES2015 and ES2016 features](/blog/v8-release-56), and shipping Ignition by default for [low-end Android devices](/blog/ignition-interpreter). Our successful work on idle-time garbage collection was presented at [PLDI 2016](https://static.googleusercontent.com/media/research.google.com/en//pubs/archive/45361.pdf). We kicked off [the Orinoco project](/blog/orinoco), a new mostly-parallel and concurrent garbage collector for V8 to reduce main thread garbage collection time. In a major refocus, we shifted our performance efforts away from synthetic micro-benchmarks and instead began to seriously measure and optimize [real-world performance](/blog/real-world-performance). For debugging, the V8 inspector was [migrated](/blog/v8-release-55) from Chromium to V8, allowing any V8 embedder (and not just Chromium) to use the Chrome DevTools to debug JavaScript running in V8. The WebAssembly prototype graduated from prototype to experimental support, in coordination with other browser vendors [experimental support for WebAssembly](/blog/webassembly-experimental). V8 received [the ACM SIGPLAN Programming Languages Software Award](http://www.sigplan.org/Awards/Software/). And another port was added: S390.

In **2017**, we finally completed our multi-year overhaul of the engine, enabling the new [Ignition and TurboFan](/blog/launching-ignition-and-turbofan) pipeline by default. This made it possible to later remove Crankshaft ([130,380 deleted lines of code](https://chromium-review.googlesource.com/c/v8/v8/+/547717)) and [Full-codegen](https://chromium-review.googlesource.com/c/v8/v8/+/584773) from the codebase. We launched Orinoco v1.0, including [concurrent marking](/blog/concurrent-marking), concurrent sweeping, parallel scavenging, and parallel compaction. We officially recognized Node.js as a first-class V8 embedder alongside Chromium. Since then, it’s impossible for a V8 patch to land if doing so breaks the Node.js test suite. Our infrastructure gained support for correctness fuzzing, ensuring that any piece of code produces consistent results regardless of the configuration it runs in.

In an industry-wide coordinated launch, V8 [shipped WebAssembly on-by-default](/blog/v8-release-57). We implemented support for [JavaScript modules](/features/modules) as well as the full ES2017 and ES2018 feature sets (including async functions, shared memory, async iteration, rest/spread properties, and RegExp features). We shipped [native support for JavaScript code coverage](/blog/javascript-code-coverage), and launched the [Web Tooling Benchmark](/blog/web-tooling-benchmark) to help us measure how V8’s optimizations impact performance for real-world developer tools and the JavaScript output they generate. [Wrapper tracing](/blog/tracing-js-dom) from JavaScript objects to C++ DOM objects and back allowed us to resolve long-standing memory leaks in Chrome and to handle the transitive closure of objects over the JavaScript and Blink heap efficiently. We later used this infrastructure to increase the capabilities of the heap snapshotting developer tool.

**2018** saw an industry-wide security event upend what we thought we knew about CPU information security with the public disclosure of [the Spectre/Meltdown vulnerabilities](https://googleprojectzero.blogspot.com/2018/01/reading-privileged-memory-with-side.html). V8 engineers performed extensive offensive research to help understand the threat for managed languages and develop mitigations. V8 shipped [mitigations](/docs/untrusted-code-mitigations) against Spectre and similar side-channel attacks for embedders that run untrusted code.

Recently, we shipped a baseline compiler for WebAssembly named [Liftoff](/blog/liftoff) which greatly reduces startup time for WebAssembly applications while still achieving predictable performance. We shipped [`BigInt`](/blog/bigint), a new JavaScript primitive that enables [arbitrary-precision integers](/features/bigint). We implemented [embedded builtins](/blog/embedded-builtins), and made it possible to [lazily deserialize them](/blog/lazy-deserialization), significantly reducing V8’s footprint for multiple Isolates. We made it possible to [compile script bytecode on a background thread](/blog/background-compilation). We started [the Unified V8-Blink Heap project](https://docs.google.com/presentation/d/12ZkJ0BZ35fKXtpM342PmKM5ZSxPt03_wsRgbsJYl3Pc) to run a cross-component V8 and Blink garbage collection in sync. And the year’s not over yet…

## Performance ups and downs

Chrome’s V8 Bench score over the years shows the performance impact of V8’s changes. (We’re using the V8 Bench because it’s one of the few benchmarks that can still run in the original Chrome beta.)

<figure>
  <img src="/_img/10-years/v8-bench.png" srcset="/_img/10-years/v8-bench@2x.png 2x" width="1247" height="572" alt="" loading="lazy">
  <figcaption>Chrome’s <a href="http://www.netchain.com/Tools/v8/">V8 Bench</a> score from 2008 to 2018</figcaption>
</figure>

Our score on this benchmark went up **4×** over the last ten years!

However, you might notice two performance dips over the years. Both are interesting because they correspond to significant events in V8’s history. The performance drop in 2015 happened when V8 shipped baseline versions of ES2015 features. These features were cross-cutting in the V8 code base, and we therefore focused on correctness rather than performance for their initial release. We accepted these slight speed regressions to get features to developers as quickly as possible. In early 2018, the Spectre vulnerability was disclosed, and V8 shipped mitigations to protect users against potential exploits, resulting in another regression in performance. Luckily, now that Chrome is shipping [Site Isolation](https://developers.google.com/web/updates/2018/07/site-isolation), we can disable the mitigations again, bringing performance back on par.

Another take-away from this chart is that it starts to level off around 2013. Does that mean V8 gave up and stopped investing in performance? Quite the opposite! The flattening of the graphs represents the V8 team’s pivot from synthetic micro-benchmarks (such as V8 Bench and Octane) to optimizing for [real-world performance](/blog/real-world-performance). V8 Bench is an old benchmark that doesn’t use any modern JavaScript features, nor does it approximate actual real-world production code. Contrast this with the more recent Speedometer benchmark suite:

<figure>
  <img src="/_img/10-years/speedometer-1.png" srcset="/_img/10-years/speedometer-1@2x.png 2x" width="1247" height="572" alt="" loading="lazy">
  <figcaption>Chrome’s <a href="https://browserbench.org/Speedometer/">Speedometer 1</a> score from 2013 to 2018</figcaption>
</figure>

Although V8 Bench shows minimal improvements from 2013 to 2018, our Speedometer 1 score went up (another) **4×** during this same time period. (We used Speedometer 1 because Speedometer 2 uses modern JavaScript features that weren’t yet supported in 2013.)

Nowadays, we have [even better](/blog/speedometer-2) [benchmarks](/blog/web-tooling-benchmark) that more accurately reflect modern JavaScript apps, and on top of that, we [actively measure and optimize for existing web apps](https://www.youtube.com/watch?v=xCx4uC7mn6Y).

## Summary

Although V8 was originally built for Google Chrome, it has always been a stand-alone project with a separate codebase and an embedding API that allows any program to use its JavaScript execution services. Over the last 10 years, the open nature of the project has helped it become a key technology not only for the Web Platform, but in other contexts like Node.js as well. Along the way the project evolved and remained relevant despite many changes and dramatic growth.

Initially, V8 supported only two instruction sets. In the last 10 years the list of supported platforms reached eight: ia32, x64, ARM, ARM64, 32- and 64-bit MIPS, 64-bit PPC, and S390. V8’s build system migrated from SCons to GYP to GN. The project moved from Denmark to Germany, and now has engineers all over the world, including in London, Mountain View, and San Francisco, with contributors outside of Google from many more places. We’ve transformed our entire JavaScript compilation pipeline from unnamed components to Full-codegen (a baseline compiler) and Crankshaft (an feedback-driven optimizing compiler) to Ignition (an interpreter) and TurboFan (a better feedback-driven optimizing compiler). V8 went from being “just” a JavaScript engine to also supporting WebAssembly. The JavaScript language itself evolved from ECMAScript 3 to ES2018; the latest V8 even implements post-ES2018 features.

The story arc of Web is a long and enduring one. Celebrating Chrome and V8’s 10th birthday is a good opportunity to reflect that even though this is a big milestone, the Web Platform’s narrative has lasted for more than 25 years. We have no doubt the Web’s story will continue for at least that long in the future. We’re committed to making sure that V8, JavaScript, and WebAssembly continue to be interesting characters in that narrative. We’re excited to see what the next decade has in store. Stay tuned!
