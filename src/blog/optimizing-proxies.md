---
title: 'Optimizing ES2015 proxies in V8'
author: 'Maya Lekova ([@MayaLekova](https://twitter.com/MayaLekova)), Optimizer of Proxies'
avatars:
  - 'maya-lekova'
date: 2017-10-05 13:33:37
tags:
  - ECMAScript
  - benchmarks
tweet: '915846050447003648'
---
Proxies have been an integral part of JavaScript since ES2015. They allow intercepting fundamental operations on objects and customizing their behavior. Proxies form a core part of projects like [jsdom](https://github.com/tmpvar/jsdom) and the [Comlink RPC library](https://github.com/GoogleChrome/comlink). Recently, we put a lot of effort into improving the performance of proxies in V8. This article sheds some light on general performance improvement patterns in V8 and for proxies in particular.

Proxies are “objects used to define custom behavior for fundamental operations (e.g. property lookup, assignment, enumeration, function invocation, etc.)” (definition by [MDN](https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Proxy)). More info can be found in the [full specification](https://tc39.es/ecma262/#sec-proxy-objects). For example, the following code snippet adds logging to every property access on the object:

```js
const target = {};
const callTracer = new Proxy(target, {
  get: (target, name, receiver) => {
    console.log(`get was called for: ${name}`);
    return target[name];
  }
});

callTracer.property = 'value';
console.log(callTracer.property);
// get was called for: property
// value
```

## Constructing proxies

The first feature we'll focus on is the **construction** of proxies. Our original C++ implementation here followed the ECMAScript specification step-by-step, resulting in at least 4 jumps between the C++ and JS runtimes as shown in the following figure. We wanted to port this implementation into the platform-agnostic [CodeStubAssembler](/docs/csa-builtins) (CSA), which is executed in the JS runtime as opposed to the C++ runtime.This porting minimizes that number of jumps between the language runtimes. `CEntryStub` and `JSEntryStub` represent the runtimes in the figure below. The dotted lines represent the borders between the JS and C++ runtimes. Luckily, lots of [helper predicates](https://github.com/v8/v8/blob/4e5db9a6c859df7af95a92e7cf4e530faa49a765/src/code-stub-assembler.h) were already implemented in the assembler, which made the [initial version](https://github.com/v8/v8/commit/f2af839b1938b55b4d32a2a1eb6704c49c8d877d#diff-ed49371933a938a7c9896878fd4e4919R97) concise and readable.

The figure below shows the execution flow for calling a Proxy with any proxy trap (in this example `apply`, which is being called when the proxy is used as a function) generated by the following sample code:

```js
function foo(…) { … }
const g = new Proxy({ … }, {
  apply: foo,
});
g(1, 2);
```

<figure>
  <img src="/_img/optimizing-proxies/0.png" intrinsicsize="1024x768" alt="">
</figure>

After porting the trap execution to CSA all of the execution happens in the JS runtime, reducing the number of jumps between languages from 4 to 0.

This change resulted in the following performance improvements::

<figure>
  <img src="/_img/optimizing-proxies/1.png" intrinsicsize="1200x742" alt="">
</figure>

Our JS performance score shows an improvement between **49% and 74%**. This score roughly measures how many times the given microbenchmark can be executed in 1000ms. For some tests the code is run multiple times in order to get an accurate enough measurement given the timer resolution. The code for all of the following benchmarks can be found [in our js-perf-test directory](https://github.com/v8/v8/blob/5a5783e3bff9e5c1c773833fa502f14d9ddec7da/test/js-perf-test/Proxies/proxies.js).

## Call and construct traps

The next section shows the results from optimizing call and construct traps (a.k.a. [`"apply"`](https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Proxy/handler/apply)" and [`"construct"`](https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Proxy/handler/construct)).

<figure>
  <img src="/_img/optimizing-proxies/2.png" intrinsicsize="1200x742" alt="">
</figure>

The performance improvements when _calling_ proxies are significant — up to **500%** faster! Still, the improvement for proxy construction is quite modest, especially in cases where no actual trap is defined — only about **25%** gain. We investigated this by running the following command with the [`d8` shell](/docs/build):

```bash
$ out/x64.release/d8 --runtime-call-stats test.js
> run: 120.104000

                      Runtime Function/C++ Builtin        Time             Count
========================================================================================
                                         NewObject     59.16ms  48.47%    100000  24.94%
                                      JS_Execution     23.83ms  19.53%         1   0.00%
                              RecompileSynchronous     11.68ms   9.57%        20   0.00%
                        AccessorNameGetterCallback     10.86ms   8.90%    100000  24.94%
      AccessorNameGetterCallback_FunctionPrototype      5.79ms   4.74%    100000  24.94%
                                  Map_SetPrototype      4.46ms   3.65%    100203  25.00%
… SNIPPET …
```

Where `test.js`’s source is:

```js
function MyClass() {}
MyClass.prototype = {};
const P = new Proxy(MyClass, {});
function run() {
  return new P();
}
const N = 1e5;
console.time('run');
for (let i = 0; i < N; ++i) {
  run();
}
console.timeEnd('run');
```

It turned out most of the time is spent in `NewObject` and the functions called by it, so we started planning how to speed this up in future releases.

## Get trap

The next section describes how we optimized the other most common operations — getting and setting properties through proxies. It turned out the [`get`](https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Proxy/handler/get) trap is more involved than the previous cases, due to the specific behavior of V8's inline cache. For a detailed explanation of inline caches, you can watch [this talk](https://www.youtube.com/watch?v=u7zRSm8jzvA).

Eventually we managed to get a working port to CSA with the following results:

<figure>
  <img src="/_img/optimizing-proxies/3.png" intrinsicsize="1200x742" alt="">
</figure>

After landing the change, we noticed the size of the Android `.apk` for Chrome had grown by **~160KB**, which is more than expected for a helper function of roughly 20 lines, but fortunately we track such statistics. It turned out this function is called twice from another function, which is called 3 times, from another called 4 times. The cause of the problem turned out to be the aggressive inlining. Eventually we solved the issue by turning the inline function into a separate code stub, thus saving precious KBs — the end version had only **~19KB** increase in `.apk` size.

## Has trap

The next section shows the results from optimizing the [`has`](https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Proxy/handler/has) trap. Although at first we thought it would be easier (and reuse most of the code of the `get` trap), it turned out to have its own peculiarities. A particularly hard-to-track-down problem was the prototype chain walking when calling the `in` operator. The improvement results achieved vary between **71% and 428%**. Again the gain is more prominent in cases where the trap is present.

<figure>
  <img src="/_img/optimizing-proxies/4.png" intrinsicsize="1200x742" alt="">
</figure>

## Set trap

The next section talks about porting the [`set`](https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Proxy/handler/set) trap. This time we had to differentiate between [named](/blog/fast-properties) and indexed properties ([elements](/blog/elements-kinds)). These two main types are not part of the JS language, but are essential for V8's efficient property storage. The initial implementation still bailed out to the runtime for elements, which causes crossing the language boundaries again. Nevertheless we achieved improvements between **27% and 438%** for cases when the trap is set, at the cost of a decrease of up to **23%** when it's not. This performance regression is due to the overhead of additional check for differentiating between indexed and named properties. For indexed properties, there is no improvement yet. Here are the complete results:

<figure>
  <img src="/_img/optimizing-proxies/5.png" intrinsicsize="1200x742" alt="">
</figure>

## Real-world usage

### Results from [jsdom-proxy-benchmark](https://github.com/domenic/jsdom-proxy-benchmark)

The jsdom-proxy-benchmark project compiles the [ECMAScript specification](https://github.com/tc39/ecma262) using the [Ecmarkup](https://github.com/bterlson/ecmarkup) tool. As of [v11.2.0](https://github.com/tmpvar/jsdom/blob/master/Changelog.md#1120), the jsdom project (which underlies Ecmarkup) uses proxies to implement the common data structures `NodeList` and `HTMLCollection`. We used this benchmark to get an overview of some more realistic usage than the synthetic micro-benchmarks, and achieved the following results, average of 100 runs:

- Node v8.4.0 (without Proxy optimizations): **14277 ± 159 ms**
- [Node v9.0.0-v8-canary-20170924](https://nodejs.org/download/v8-canary/v9.0.0-v8-canary20170924898da64843/node-v9.0.0-v8-canary20170924898da64843-linux-x64.tar.gz) (with only half of the traps ported): **11789 ± 308 ms**
- Gain in speed around 2.4 seconds which is **~17% better**

<figure>
  <img src="/_img/optimizing-proxies/6.png" intrinsicsize="1200x742" alt="">
</figure>

- [Converting `NamedNodeMap` to use `Proxy`](https://github.com/domenic/jsdom-proxy-benchmark/issues/1#issuecomment-329047990) increased processing time by
    - **1.9 s** on V8 6.0 (Node v8.4.0)
    - **0.5 s** on V8 6.3 (Node v9.0.0-v8-canary-20170910)

<figure>
  <img src="/_img/optimizing-proxies/7.png" intrinsicsize="1028x634" alt="">
</figure>

:::note
**Note:** These results were provided by [Timothy Gu](https://github.com/TimothyGu). Thanks!
:::

### Results from [Chai.js](https://chaijs.com/)

Chai.js is a popular assertion library which makes heavy use of proxies. We've created a kind of real-world benchmark by running its tests with different versions of V8 an improvement of roughly **1s out of more than 4s**, average of 100 runs:

- Node v8.4.0 (without Proxy optimizations): **4.2863 ± 0.14 s**
- [Node v9.0.0-v8-canary-20170924](https://nodejs.org/download/v8-canary/v9.0.0-v8-canary20170924898da64843/node-v9.0.0-v8-canary20170924898da64843-linux-x64.tar.gz) (with only half of the traps ported): **3.1809 ± 0.17 s**

<figure>
  <img src="/_img/optimizing-proxies/8.png" intrinsicsize="1200x742" alt="">
</figure>

## Optimization approach

We often tackle performance issues using a generic optimization scheme. The main approach that we followed for this particular work included the following steps:

- Implement performance tests for the particular sub-feature
- Add more specification conformance tests (or write them from scratch)
- Investigate the original C++ implementation
- Port the sub-feature to the platform-agnostic CodeStubAssembler
- Optimize the code even further by hand-crafting a [TurboFan](/docs/turbofan) implementation
- Measure the performance improvement.

This approach can be applied to any general optimization task that you may have.
