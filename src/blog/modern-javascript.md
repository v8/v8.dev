---
title: 'ES2015, ES2016, and beyond'
author: 'the V8 team, ECMAScript Enthusiasts'
date: 2016-04-29 13:33:37
tags:
  - ECMAScript
---
The V8 team places great importance on the evolution of JavaScript into an increasingly expressive and well-defined language that makes writing fast, safe, and correct web applications easy. In June 2015, the [ES2015 specification](https://www.ecma-international.org/ecma-262/6.0/) was ratified by the TC39 standards committee, making it the largest single update to the JavaScript language. New features include [classes](https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Classes), [arrow functions](https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Functions/Arrow_functions), [promises](https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Promise), [iterators / generators](https://developer.mozilla.org/en-US/docs/Web/JavaScript/Guide/Iterators_and_Generators), [proxies](https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Proxy), [well-known symbols](https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Symbol#Well-known_symbols), and additional syntactic sugar. TC39 has also increased the cadence of new specifications and released the [candidate draft for ES2016](https://tc39.github.io/ecma262/2016/) in February 2016, to be ratified this summer. While not as expansive as the ES2015 update due to the shorter release cycle, ES2016 notably introduces the [exponentiation operator](https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Operators/Arithmetic_Operators#Exponentiation) and [`Array.prototype.includes`](https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Array/includes).

Today we’ve reached an important milestone: **V8 supports ES2015 and ES2016**. You can use the new language features today in Chrome Canary, and they will ship by default in Chrome 52.

Given the nature of an evolving spec, the differences between various types of conformance tests, and the complexity of maintaining web compatibility, it can be difficult to determine when a certain version of ECMAScript is considered fully supported by a JavaScript engine. Read on for why spec support is more nuanced than version numbers, why proper tail calls are still under discussion, and what caveats remain at play.

## An evolving spec

When TC39 decided to publish more frequent updates to the JavaScript specification, the most up-to-date version of the language became the master, draft version. Although versions of the ECMAScript spec are still produced yearly and ratified, V8 implements a combination of the most recently ratified version (e.g. ES2015), certain features which are close enough to standardization that they are safe to implement (e.g. the exponentiation operator and Array.prototype.includes() from the ES2016 candidate draft), and a collection of bug fixes and web compatibility amendments from more recent drafts. Part of the rationale for such an approach is that language implementations in browsers should match the specification, even if the it’s the specification that needs to be updated. In fact, the process of implementing a ratified version of the spec often uncovers many of the fixes and clarifications that comprise the next version of the spec.

<figure>
  <img src="/_img/modern-javascript/shipped-features.png" alt="">
  <figcaption>Currently shipping parts of the evolving ECMAScript specification</figcaption>
</figure>

For example, when implementing the ES2015 [RegExp sticky flag](https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/RegExp/sticky), the V8 team discovered that the semantics of the ES2015 spec broke many existing sites (including all sites using versions 2.x.x of the the popular [XRegExp](https://github.com/slevithan/xregexp) library). Since compatibility is a cornerstone of the web, engineers from the V8 and Safari JavaScriptCore teams [proposed an amendment](https://github.com/tc39/ecma262/pull/511) to the RegExp specification to fix the breakage, which was agreed upon by TC39. The amendment won't appear in a ratified version until ES2017, but it's still a part of the ECMAScript language and we've implemented it in order to ship the RegExp sticky flag.

The continual refinement of the language specification and the fact that each version (including the yet-to-be-ratified draft) replaces, amends, and clarifies previous versions makes it tricky to understand the complexities behind ES2015 and ES2016 support. While it's impossible to state succinctly, it's perhaps most accurate to say that _V8 supports compliance with the “continually maintained draft future ECMAScript standard”_!

## Measuring conformance

In an attempt to make sense of this specification complexity, there are a variety of ways to measure JavaScript engine compatibility with the ECMAScript standard. The V8 team, as well as other browser vendors, use [the Test262 test suite](https://github.com/tc39/test262) as the gold standard of conformance to the continually maintained draft future ECMAScript standard. This test suite is continually updated to match the spec and it provides 16,000 discrete functional tests for all the features and edge cases which make up a compatible, compliant implementation of JavaScript. Currently V8 passes approximately 98% of test262, and the remaining 2% are a handful of edge cases and future ES features not yet ready to be shipped.

Since it’s difficult to skim the enormous number of test262 tests, other conformance tests exist, such as the [Kangax compatibility table](http://kangax.github.io/compat-table/ES2015/). Kangax makes it easy to skim to see whether a particular feature (like [arrow functions](https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Functions/Arrow_functions)) has been implemented in a given engine, but doesn’t test all the conformance edge cases that test262 does. Currently, Chrome Canary scores a 98% on the Kangax table for ES2015 and 100% on the sections of Kangax corresponding to ES2016 (e.g. the sections labelled “2016 features” and “2016 misc” under the ESnext tab).

The remaining 2% of the Kangax ES2015 table tests [proper tail calls](http://www.2ality.com/2015/06/tail-call-optimization.html), a feature which has been implemented in V8, but deliberately turned off in Chrome Canary due to outstanding developer experience concerns detailed below. With the “Experimental JavaScript features” flag enabled, which forces this feature on, Canary scores 100% on the entirety of the Kangax table for ES2015.

## Proper tail calls

Proper tail calls have been implemented but not yet shipped given that a change to the feature is [currently under discussion at TC39](https://github.com/tc39/proposal-ptc-syntax). ES2015 specifies that strict mode function calls in tail position should never cause a stack overflow. While this is a useful guarantee for certain programming patterns, the current semantics have two problems. First, since the tail call elimination is implicit, it can be [difficult for programmers to identify](http://2ality.com/2015/06/tail-call-optimization.html#checking-whether-a-function-call-is-in-a-tail-position) which functions are actually in tail call position. This means that developers may not discover misplaced attempted tail calls in their programs until they overflow the stack. Second, implementing proper tail calls requires eliding tail call stack frames from the stack, which loses information about execution flow. This in turn has two consequences:

1. It makes it more difficult to understand during debugging how execution arrived at a certain point since the stack contains discontinuities, and
2. [`Error.prototype.stack`](https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Error/Stack) contains less information about execution flow which may break telemetry software that collects and analyzes client-side errors.

Implementing a [shadow stack](https://bugs.webkit.org/attachment.cgi?id=274472&action=review) can improve the readability of call stacks, but the V8 and DevTools teams believe that debugging is easiest, most reliable, and most accurate when the stack displayed during debugging is completely deterministic and always matches the true state of the actual virtual machine stack. Moreover, a shadow stack is too expensive performance-wise to turn on all the time.

For these reasons, the V8 team strongly support denoting proper tail calls by special syntax. There is a pending [TC39 proposal](https://github.com/tc39/proposal-ptc-syntax) called syntactic tail calls to specify this behavior, co-championed by committee members from Mozilla and Microsoft. We have implemented and staged proper tail calls as specified in ES2015 and started implementing syntactic tail calls as specified in the new proposal. The V8 team plans to resolve the issue at the next TC39 meeting before shipping implicit proper tail calls or syntactic tail calls by default. You can test out each version in the meantime by using the V8 flags `--harmony-tailcalls` and `--harmony-explicit-tailcalls`.

## Modules

One of the most exciting promises of ES2015 is support for JavaScript modules to organize and separate different parts of an application into namespaces. ES2015 specifies [`import`](https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Statements/import) and [`export`](https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Statements/export) declarations for modules, but not how modules are loaded into a JavaScript program. In the browser, loading behavior was recently specified through [`<script type="module">`](https://blog.whatwg.org/js-modules). Although additional standardization work is needed to specify advanced dynamic module-loading APIs, Chromium support for module script tags is already [in development](https://groups.google.com/a/chromium.org/d/msg/blink-dev/uba6pMr-jec/tXdg6YYPBAAJ). You can track implementation work on the [launch bug](https://bugs.chromium.org/p/v8/issues/detail?id=1569) and read more about experimental loader API ideas in the [whatwg/loader](https://github.com/whatwg/loader) repository.

## ESnext and beyond

In the future, developers can expect ECMAScript updates to come in smaller, more frequent updates with shorter implementation cycles. The V8 team is already working to bring upcoming features such as [`async`/`await`](https://github.com/tc39/ecmascript-asyncawait) keywords, [`Object.values`](https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Object/values) / [`Object.entries`](https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Object/entries), [`String.prototype.{padStart,padEnd}`](http://tc39.github.io/proposal-string-pad-start-end/) and [RegExp lookbehind](/blog/regexp-lookbehind-assertions) to the runtime. Check back for more updates on our ESnext implementation progress and performance optimizations for existing ES2015 and ES2016+ features.

We strive to continue evolving JavaScript and strike the right balance of implementing new features early, ensuring compatibility and stability of the existing web, and providing TC39 implementation feedback around design concerns. We look forward to seeing the incredible experiences developers build with these new features.
